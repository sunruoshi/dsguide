# Chapter I：基础篇

### 1.1 什么是数据结构

> 在计算机科学中，数据结构（英语：$$data$$ $$structure$$）是计算机中存储、组织数据的方式。
>
> \-- $$Wikipedia$$

按照维基百科中的定义，一个数据结构有两个重要的属性，即存储数据（容器）和组织数据（方法）。通俗一点来说，数据结构是一种「人为设计出来用于维护数据之间关系的工具」 。

例如，有 $$5$$ 个字符串：$$Alice$$，$$Bob$$， $$Celine$$， $$David$$，$$Elizabeth$$，如果这些字符串仅代表 $$5$$ 个人的名字，那么在使用 $$5$$ 个变量来存储这些数据即可。但是，实际上这 $$5$$ 个名字之间存在一种 「关系」 ：这些人都是 $$A$$ 班的学生。那么，在计算机中，如果仅仅使用变量来存储这些数据，是无法体现出这种关系的。

这种时候，我们就需要使用一个数组 $$A$$，代表 $$A$$ 班，然后将这 $$5$$ 个字符串放入数组 $$A$$ 中：

```cpp
#include <string>
string A[5] = {"Alice", "Bob", "Celine", "David", "Elizabeth"};
```

这样，在存储这些数据的同时，通过这些数据「同属于数组 $$A$$ 的元素」这一点，来维护这些人都是 $$A$$ 班的学生这种关系。这只有通过使用数据结构（这里是数组）来实现。这里的数组 $$A$$ 就是一个存储数据的「容器」，它是「$$A$$ 班所有学生名字的集合」。

再进一步思考：$$A$$ 班的学生人数并非一成不变，有的时候会有新的同学加入，也会有旧的同学离开。在这种时候我们希望能够「动态的」维护这些数据，那么使用大小不能改变的数组就不太方便了。为了达成这个目的，我们需要一种新的数据结构，即「可以改变大小的数组」，来继续维护这种关系。这时候就可以使用 $$vector$$ ：

```cpp
#include <vector>
vector<string> A = {"Alice", "Bob", "Celine", "David", "Elizabeth"};
```

如果有新的同学加入，我们就可以使用 $$insert()$$ 方法向 $$A$$ 中增加成员，而有旧的同学离开时，就使用 $$erase()$$ 方法来将对应的成员移除。这些「方法」是跟容器绑定的，被用来操作容器中的数据。

这些方法加上容器本身，就共同构成了一个数据结构 $$vector$$  。

从上面的例子可以知道，数据结构是「人为设计出来用来解决计算机中某些特定问题的工具」。其容器和方法都可以根据具体需求来分别设计，其目的都是简单而高效的解决问题。从简单的栈，队列，链表，到复杂的线段树，$$splay$$ 等，都是为了方便高效的解决某些问题而被设计出来的。

所以在学习数据结构时，你最需要了解的，就是「这种数据结构是为了解决什么问题而被设计出来的」。它从设计上是如何解决这些问题，如何提高性能的。一旦想明白了这些问题，你就会知道该在什么时候使用数组或是链表，为什么没有经过堆优化的 $$Dijkstra$$ 算法、没有懒标记的线段树和不能保持平衡的二叉搜索树没有实用价值，在使用这些数据结构的时候自然能够运用自如。否则就会陷入云里雾里，感到难以掌握。

### 1.2 容器的类型

在计算机中，数据结构中的容器的结构大体上可以分为三种类型：

1. 线性结构：一般用来维护简单的数据关系。
2. 树形结构：一般用于提升「方法」的性能。
3. 网状结构：一般用于维护复杂的的数据关系，如一些图论模型。

而在代码实现上，又可以分为「静态实现」（使用数组）和「动态实现」（使用指针）。

在生产环境中的数据结构大多都是使用动态实现，而在算法竞赛中，由于使用指针容易出错，所以除了某些特殊的树之外，更多的时候是使用静态实现。

### 1.3 从容器的角度看数组

数组（$$Array$$）是计算机中最基本的一种「容器」。它最重要的特点是：

> 数组在内存地址上是「连续」的。

只要理解了这一点，就可以理解数组的所有特点，包括为什么数组在声明时一定要声明「大小」，而且数组的「大小」一旦声明了就不可以再改变，以及为什么数组的 $$IO$$ 性能非常高。

我们知道程序是运行在计算机内存中的，而计算机的内存就像一个很大的储物柜，这个储物柜的每个格子都是一个独立的小空间，这个空间的大小为一个「字节（$$Byte$$）」，并且都有一个「唯一」的编号，这个编号就叫做「内存地址」。

在计算机中，内存地址（即每个小格子的编号）都是一个无符号整数，而这些编号是连续的。

例如某个格子的编号为「0x13」，那么它的下一个格子的编号就一定是「0x14」，再下一个格子的编号就一定是「0x15」…… 这一点跟现实中的储物柜非常相像。

通过 C++ 中的「指针」我们可以很直观的看到内存地址。例如编译并执行下面这一段代码：

```cpp
#include <iostream>
using namespace std;

int main() {
    int* a;
    cout << a << endl;
    return 0;
}
```

我们声明了一个整型的指针变量 $$a$$，然后直接输出 $$a$$ 的值，你可以在终端中看到如下输出：

```
0x13
```

你如果自己运行这段代码，输出不一定就是 `0x13` ，但是一定也是一个用 $$16$$ 进制表示的整数，这就是「内存地址」。如果我们把上面的修改一下：

```cpp
#include <iostream>
using namespace std;

int main() {
    int a = 5;
    cout << "Addr:  " << &a << endl;
    cout << "Value: " << a << endl;
    return 0;
}
```

我们这次声明一个整型的变量 $$a$$，并赋与一个初始值，然后使用 C++ 的「取地址运算符」$$\&$$，来输出变量 $$a$$ 的内存地址，那么编译并运行之后可以在终端中看到如下输出：

```
Addr:  0x7ff7b4dbd808
Value: 5
```

这样就可以看的很清楚，变量 $$a$$ 其实就是计算机内存这个大储物柜中的一个小格子。这个格子的编号是 `0x7ff7b4dbd808`，变量名 $$a$$ 只是这个编号的一个「别名」，而变量的值就是存放在这个格子中的「物品」，在这个例子里，就是一个整数 $$5$$ 。

现在我们尝试把变量 $$a$$ 声明成一个长度为 $$5$$ 的数组，并依次打印数组中每个成员的内存地址：

```cpp
#include <iostream>
using namespace std;

int main() {
    int a[5];
    for (int i = 0; i < 5; i++) {
        cout << &a[i] << endl;
    }
    return 0;
}
```

编译并运行之后可以看到如下输出：

```
0x7ff7b63bd7f0
0x7ff7b63bd7f4
0x7ff7b63bd7f8
0x7ff7b63bd7fc
0x7ff7b63bd800
```

可以很清楚的看到，数组成员在内存地址上是「连续」分配的。由于一个 $$int$$ 型变量要占用 $$4$$ 个字节，所以 $$a[0]$$ 之后每个成员的地址都比上一个成员大 $$4$$ 。

从中可以看到计算机对于数组内存分配的逻辑是：

首先分配一个「起始地址」，然后根据数组类型所占用的字节数，在起始地址之后分配一段「连续」的内存空间给这个数组。换句话说，要给一个数组分配内存空间，就必须先根据数组类型和数组的长度来计算出这个数组的「大小」，然后在内存中找到一块足够的「连续空间」，来分配给这个数组。

这就是为什么在声明数组时就「必须」提供数组的长度。因为如果不提供，计算机就无法计算出这个数组所需要的内存空间大小，自然就没有办法去找到一段连续的内存空间用来分配了。

根据同样的道理，为什么数组的大小一旦声明了就不能再改变了呢？以上面的例子为例：

假设我觉得数组 $$a$$ 还不够大，想要再增加一个位置，把长度从 $$5$$ 变为 $$6$$ 。按照道理来说，$$a[5]$$ 的地址应该紧跟在 $$a[4]$$ 的后面，即 `0x7ff7b63bd804` 。但是由于计算机内存分配的随机性，`0x7ff7b63bd804` 这个地址「可能」已经被分配给别的变量了。为了避免这种冲突，计算机不允许在声明之后再去改变数组的大小。

这种内存分配逻辑带来的好处就是计算机对于数组成员的寻址速度非常快，数组成员的「下标」都可以通过对「首地址」进行数学计算来非常方便的得到。而不好的地方自然就是空间分配的不灵活了。

由于数组的大小一旦声明就不能再改变，而不论是在算法竞赛还是在生产环境中，很多时候我们在声明数组的时候是不能够确定数组所需的大小的。一种通常情况下的处理是，直接把数组的大小声明为一个很大的值。在算法竞赛中，这样或许还能够接受，但是在生产环境中，这是对于计算机「宝贵」的内存的一种极大的浪费，是绝对无法接受的。这种时候，我们就需要一种在内存分配上更加「灵活」的数组，在 C++ 中，就是可变数组 $$vector$$ 。

显然，如果想要一个数组的大小可变，那么它在内存地址上就不可能「连续」了。这带来的问题就是 $$IO$$ 性能的下降。不过相比起内存空间的浪费，这个问题是「可以接受」的。在计算机中有很多数据结构都是这样，它在某一方面有特别的优势，在另一方面就会存在短板。这个时候你就需要根据当前最主要的需求去做「取舍」。这就需要你能够掌握各种数据结构的特性和适用场景了。

对于在内存地址上「不连续」的容器，其内部成员之间通常都是通过「链式结构」来维系。在下一章中，我们就来讨论一种最基本，也是最重要的「链式结构」容器：链表。
